<!DOCTYPE html>
<html>
<head>
    <meta charset=utf-8 />
    <title>Pandemic</title>
    <link rel="stylesheet" type="text/css" media="screen" href="css/main.css" />
    <script type="text/javascript" src="js/third-party/jquery-1.9.0.min.js"></script>
    <script type="text/javascript" src="js/third-party/seedrandom.min.js"></script>
    <script>
        function gridPoint(clone) {
            if(clone) {
                this.x = clone.x;
                this.y = clone.y;
            }
        }
        gridPoint.prototype = {
            x: 0,
            y: 0
        }
        gridPoint.prototype.setCoords = function(x,y) {
            this.x = x;
            this.y = y;
        }
        gridPoint.prototype.addCoords = function(x,y) {
            this.x += x;
            this.y += y;
        }
        var SQUARE_SIZE = 10,
            levels = [{pieceSize: 3, shape:'r'},{pieceSize: 4, shape:'l'},{pieceSize: 7, shape: 'c'},{pieceSize: 6, shape: 's'},{pieceSize: 5, shape: 's'},{pieceSize: 5, shape: 'r'},{pieceSize: 5, shape: 'r'},{pieceSize: 5, shape: 'r'},{pieceSize: 5, shape: 'r'},{pieceSize: 5, shape: 'r'},{pieceSize: 5, shape: 'r'}],
            gridSize = 5,grid=[],
            directions = [{y:-1,x:0},{y:0,x:-1},{y:1,x:0},{y:0,x:1}],
            currPoint = new gridPoint(), topLeft = new gridPoint(), bottomRight = new gridPoint(),
            pieceImage,pieceGraphic;

        // Canvas to draw the shape on
        pieceGraphic = document.createElement( 'canvas' );
        pieceGraphic.width = 500;
        pieceGraphic.height = 500;

        // Canvas to copy the drawn shape on with a fit size
        pieceImage = document.createElement( 'canvas' );
        pieceImage.width = 100;
        pieceImage.height = 100;

        // Create the drid storage object for keeping track of shape location
        for(var i = 0; i < gridSize; i++) {
            grid[i] = [];
        }

        $(function() {
            var i,j,n,initialDirection,
                ctx,rand,current,lastTurn,direction;
            // Generate the tetris shapes based on the options defined in each level
            for(i = 0; i < levels.length; i++) {
                levels[i].id = i;

                initialDirection = Math.floor(Math.random()*4);
                ctx = pieceGraphic.getContext("2d");
                pieceGraphic.width = pieceGraphic.width; // Clear the piece graphic
                ctx.translate(pieceGraphic.width / 2, pieceGraphic.height / 2);

                ctx.fillStyle = "rgba(255, 255, 0, 255)";
                ctx.strokeStyle = "rgba(170, 0, 0, 255)";
                ctx.lineWidth = 1;

                direction = initialDirection;
                lastTurn = -1;
                currPoint.setCoords(0,0);
                topLeft.setCoords(0,0);
                bottomRight.setCoords(0,0);
                levels[i].points = [new gridPoint(currPoint)];
                nextDirection = 0;

                // Generate the shape by adding on squares in a snake fashion
                for(j = 0, n = levels[i].pieceSize - 1; j < n; j++) {
                    // Change the direction of the "snake" while drawing the piece depending on shape selected
                    switch(levels[i].shape) {
                        case 'r':
                            if(j == 0)
                                var turn_point = Math.floor(Math.random() * (n-1)) + 1;         
                            else if(j == turn_point)
                                if(Math.random() > 0.5)
                                    direction++;
                                else
                                    direction--;
                        break;
                        case 'c':
                        case 's':
                            if(j == 0) {
                                var lastDirection = -1;
                                var turn_point = Math.floor(Math.random() * (n-3)) + 1;
                                var turn_point2 = turn_point + Math.floor(Math.random() * (n - turn_point - 2)) + 2;
                            } else if(j == turn_point || j == turn_point2) {
                                if(!nextDirection) {
                                    if(Math.random() > 0.5) {
                                        if(levels[i].shape == 'c')
                                            nextDirection = 1;
                                        else
                                            nextDirection = -1;
                                        direction++;
                                    } else {
                                        if(levels[i].shape == 'c')
                                            nextDirection = -1;
                                        else
                                            nextDirection = 1;
                                        direction--;
                                    }
                                } else {
                                    direction += nextDirection;                                    
                                }
                            } else if(j > turn_point2) {
                                rand = Math.random();
                                if(rand < 0.5) {
                                    rand *= 2;
                                    if(rand < 0.5)
                                        direction++;
                                    else 
                                        direction--;
                                }
                            }
                        break;
                    }

                    if(direction < 0)
                        direction = direction+4;
                    if(direction > 3)
                        direction = direction%4;

                    currPoint.addCoords(directions[direction].x, directions[direction].y);
                    if(topLeft.x > currPoint.x)
                        topLeft.x = currPoint.x;
                    if(topLeft.y > currPoint.y)
                        topLeft.y = currPoint.y;
                    if(bottomRight.x < currPoint.x)
                        bottomRight.x = currPoint.x;
                    if(bottomRight.y < currPoint.y)
                        bottomRight.y = currPoint.y;
                    levels[i].points.push(new gridPoint(currPoint));
                }

                // end generation
                // start drawing shapes

                for(var j = 0; j < levels[i].points.length; j++) {
                    ctx.beginPath();
                    ctx.rect(levels[i].points[j].x*SQUARE_SIZE, levels[i].points[j].y*SQUARE_SIZE, SQUARE_SIZE-1, SQUARE_SIZE-1);
                    ctx.fill();
                    /*ctx.beginPath();
                    ctx.rect(levels[i].points[j].x*SQUARE_SIZE+0.5, levels[i].points[j].y*SQUARE_SIZE+0.5, SQUARE_SIZE-1, SQUARE_SIZE-1);
                    ctx.stroke();*/

                    // Push points so that the top left part of the shape is 0,0
                    levels[i].points[j].addCoords(topLeft.x*-1, topLeft.y*-1);
                }
                levels[i].height = bottomRight.y - topLeft.y + 1;
                levels[i].width = bottomRight.x - topLeft.x + 1;
                pieceImage.height = SQUARE_SIZE * levels[i].height;
                pieceImage.width = SQUARE_SIZE * levels[i].width;
                pieceImageCtx = pieceImage.getContext('2d');
                pieceImageCtx.drawImage(pieceGraphic,pieceGraphic.width / -2 - topLeft.x*SQUARE_SIZE, pieceGraphic.height / -2 - topLeft.y*SQUARE_SIZE);

                current = $('#tb_gene').clone().removeAttr('id').addClass('active geneBlock gene_'+i).data('levelId',i);
                $('img',current).attr('src', pieceImage.toDataURL());

                $('.toolbox').append(current);

                // end drawing shapes
            }
            $('#tb_board .grid').css('width',gridSize*SQUARE_SIZE).css('height',gridSize*SQUARE_SIZE);
            $('.toolbox').on('mousedown','.geneBlock',function(event) {
                event.preventDefault();
                var i,valid,element,position,
                    piece = $(this),
                    originalElement = piece.find('img'),
                    current = levels[piece.data('levelId')],
                    adjust = originalElement.parents('.overlay').offset(),
                    mousePosition = { left:event.clientX , top:event.clientY },
                    gridElement = $('#tb_board .grid'),
                    gridPosition = gridElement.offset();

                if(piece.hasClass('placed')) {
                    element = piece;
                    var mouseOffsetGrid = { left: mousePosition.left - gridPosition.left, top: mousePosition.top - gridPosition.top }

                    // if the grid point you clicked on isn't actually this element, mousedown on the gridpoint owner and stop this at once
                    if(!grid[Math.floor(mouseOffsetGrid.left/10)][Math.floor(mouseOffsetGrid.top/10)]) {
                        event.stopImmediatePropagation();
                        return false;
                    }
                    else if(grid[Math.floor(mouseOffsetGrid.left/10)][Math.floor(mouseOffsetGrid.top/10)].id != current.id) {
                        current = grid[Math.floor(mouseOffsetGrid.left/10)][Math.floor(mouseOffsetGrid.top/10)];
                        element = piece = $('.gene_'+current.id,gridElement);
                        originalElement = piece.find('img');
                    }

                    for(i = 0; i < current.points.length; i++) {
                        delete grid[current.points[i].x + current.placement.x][current.points[i].y + current.placement.y];
                        $('.geneBlock.active.gene_'+piece.data('levelId')).removeClass('used');
                        current.used = false;
                    }
                    var elementOffset = element.offset();
                    position = { left: elementOffset.left - adjust.left, top: elementOffset.top - adjust.top};                   
                }
                else {
                    if(current.used)
                        return false;
                    else
                        element = piece.clone(true).removeClass('active').empty().append(originalElement.clone());
                    position = { left: mousePosition.left - adjust.left - originalElement.width(), top: mousePosition.top - adjust.top - originalElement.height()};
                }

                originalElement.parents('.toolbox').append(element);
                element.addClass('dragging').css('top',position.top).css('left', position.left);

                current.placement = new gridPoint();
                gridPosition.top -= adjust.top;
                gridPosition.left -= adjust.left;

                $('.toolbox').on('mousemove.toolbox',null,{position:position,gridElement:gridElement,gridPosition:gridPosition,element:element,mousePosition:mousePosition,currentLevel:current,placement:current.placement},function(event) {
                    event.data.position.left += event.clientX - event.data.mousePosition.left;
                    event.data.position.top += event.clientY - event.data.mousePosition.top;
                    event.data.mousePosition.left = event.clientX;
                    event.data.mousePosition.top = event.clientY;
                    if(event.data.gridPosition.left - SQUARE_SIZE/2 < event.data.position.left && event.data.gridPosition.top - SQUARE_SIZE/2 < event.data.position.top &&
                      event.data.gridPosition.left + event.data.gridElement.width() + SQUARE_SIZE/2 > event.data.position.left + event.data.currentLevel.width*SQUARE_SIZE && event.data.gridPosition.top + event.data.gridElement.height() + SQUARE_SIZE/2 > event.data.position.top + event.data.currentLevel.height*SQUARE_SIZE) {
                        event.data.placement.x = Math.round((event.data.position.left - event.data.gridPosition.left) / 10);
                        event.data.placement.y = Math.round((event.data.position.top - event.data.gridPosition.left) / 10);
                        event.data.element.css('left',event.data.gridPosition.left + event.data.placement.x*10 - 1)
                            .css('top',event.data.gridPosition.top + event.data.placement.y*10 - 1);
                        valid = true;
                        for(i = 0; i < event.data.currentLevel.points.length; i++)
                            if(grid[event.data.currentLevel.points[i].x + event.data.placement.x][event.data.currentLevel.points[i].y + event.data.placement.y]) 
                                valid = false;

                        if(valid) {
                            event.data.element.addClass('valid');
                            event.data.currentLevel.validPlacement = true;                                
                        } else if(event.data.currentLevel.validPlacement) {
                            event.data.element.removeClass('valid');
                            event.data.currentLevel.validPlacement = false;                            
                        }
                    }
                    else {
                        if(event.data.currentLevel.validPlacement) {
                            event.data.element.removeClass('valid');
                            event.data.currentLevel.validPlacement = false;                            
                        }
                        event.data.element.css('left',event.data.position.left).css('top',event.data.position.top);
                    }
                });
                $(document).on('mouseup.toolbox',null,{currentLevel:current,element:element,gridElement:gridElement},function(event) {
                    if(event.data.currentLevel.validPlacement) {
                        $('.geneBlock.active.gene_'+event.data.currentLevel.id).addClass('used');
                        event.data.currentLevel.used = true;
                        for(i = 0; i < event.data.currentLevel.points.length; i++) {
                            grid[event.data.currentLevel.points[i].x + event.data.currentLevel.placement.x][event.data.currentLevel.points[i].y + event.data.currentLevel.placement.y] = event.data.currentLevel;
                        }
                        event.data.element.removeClass('valid dragging').addClass('placed').css('left',event.data.currentLevel.placement.left * SQUARE_SIZE).css('top',event.data.currentLevel.placement.top * SQUARE_SIZE).appendTo(event.data.gridElement);
                    } else {
                        event.data.element.remove();
                    }
                    $('.toolbox').off('mousemove.toolbox');
                    $(document).off('mouseup.toolbox');
                });
            })
        })
    </script>
</head>
<body>
    <div class="overlay toolbox">
        <div id="tb_board">
            <div><div class="grid"></div></div>
        </div>
        <div id="tb_gene">
            <p class="image"><img src="" draggable="false" /></p><p class="name">Test</p>
        </div>
    </div>
</body>
</html>